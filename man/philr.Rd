% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/build_phylo_ilr.R
\name{philr}
\alias{build.phylo.ilr}
\alias{philr}
\title{Data transformation and driver of PhILR.}
\usage{
philr(df, tree, sbp = NULL, part.weights = "uniform",
  ilr.weights = "uniform", return.all = FALSE, n_cores = 1,
  tip.boosted = NULL)
}
\arguments{
\item{df}{matrix of data to be transformed (samples are rows,
compositional parts are columns) - zero must be dealt with either with pseudocount,
multiplicative replacement, or another method.}

\item{tree}{a \code{phylo} class tree object that is binary (see \code{\link[ape]{multi2di}})}

\item{sbp}{(Optional) give a precomputed sbp matrix \code{link{phylo2sbp}}
if you are going to build multiple ILR bases (e.g., with different weightings).}

\item{part.weights}{weightings for parts, can be a named vector with names
corresponding to \code{colnames(df)} otherwise can be a string, options include:
\describe{
\item{\code{'uniform'}}{(default) uses the uniform reference measure}
\item{\code{'gm.counts'}}{geometric mean of parts of df}
\item{\code{'anorm'}}{aitchison norm of parts of df}
\item{\code{'anorm.x.gm.counts'}}{\code{'anorm'*'gm.counts'}, often gives good results}
}}

\item{ilr.weights}{weightings for the ILR coordiantes can be a named vector with names
corresponding to names of internal nodes of \code{tree} otherwise can be a string,
options include:
\describe{
\item{\code{'uniform'}}{(default) no weighting of the ILR basis}
\item{\code{'blw'}}{sum of children's branch lengths}
\item{\code{'blw.sqrt'}}{square root of \code{'blw'} option}
\item{\code{'mean.descendants'}}{sum of children's branch lengths PLUS the sum of
each child's mean distance to its descendent tips}
}}

\item{return.all}{return all computed parts (e.g., computed sign matrix(\code{sbp} ),
part weightings (code{p}), ilr weightings (code{ilr.weights}), contrast matrix (\code{V}))
as a list (default=\code{FALSE}) in addition to in addition to returning the transformed data (\code{df.ilrp}).
If \code{return.all==FALSE} then only returns the transformed data (not in list format)
If \code{FALSE} then just returns list containing \code{df.ilrp}.}

\item{n_cores}{(Optional) integer specifying the number of cores to use. See Details.}

\item{tip.boosted}{(Optional) numeric factor to multiply tip lengths by to 'boost their importance
in the weightings. \emph{Note:} this feature is largely unstudied.}
}
\description{
This is the main function for building the phylogenetic ILR basis, calculating the
weightings (of the parts and the ILR coordinates) and then transforming the data.
}
\details{
This is a utility function that pulls together a number of other functions
in \code{philr}. The steps that are executed are as follows:
\enumerate{
\item First Create sbp (sign matrix) if not given
\item Second Create parts weightings if not given
\item Third Shift the dataset with respect to the new reference measure (e.g., part weightings)
\item Fourth Create the basis contrast matrix from the sign matrix and the reference measure
\item Fifth Transform the data based on the contrast matrix and the reference measure
\item Sixth Calculate the specified ILR weightings and multiply each balance by the corresponding weighting
}
Note for both the reference measure (part weightings) and the ILR weightings, specifying \code{‘uniform’} will
give the same results as not weighting at all.\cr \cr
Parallelization is done through \code{parallel} package using type "FORK".
Note parallelization is rarely needed, even for trees of upwards of 40,000 leaves.
}
\examples{
library(phyloseq)
data(CSS)
df <- t(otu_table(CSS))
df <- df + 0.65   # add a small pseudocount
tree <- phy_tree(CSS)
df.philr <- philr(df, tree, part.weights='anorm.x.gm.counts', ilr.weights='blw.sqrt', return.all=FALSE, n_cores=1)
df.philr[1:5,1:5]
}
\author{
Justin Silverman
}
\seealso{
\code{\link{phylo2sbp}} \code{\link{calculate.blw}}
}

